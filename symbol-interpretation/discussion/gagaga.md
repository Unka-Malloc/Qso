# GaGaGa

我学习这一切的最初想法, 就是为了给 SDQL 适配一个可运行的后台编译器. 因此, 我认真的思考过一个问题: 有没有什么成品的GC平台可以用?

编程语言世界如此广阔, 可是目光所及, 就只有 JVM 可用. SDQL 最初的版本就是用 Scala 实现的, 但是其受限于 JVM 的原因, 无法发挥最大的性能. 为了尽可能获取最高的性能, SDQL 转向了使用 C++ 实现.&#x20;

这个 C++ 版本的 SDQL 的最大的问题在于: 它在事实上是不可用的. 例如, 它需要 Root 权限手动编译 C++ 程序, 它需要严苛的依赖库版本(没有使用任何包管理器). 它繁琐的设计意味着这门语言从设计之初就从来没有考虑过让人真正使用它.

为 SDQL 实现的编译器前端 (解析器 + 优化器) 对我有重要的意义, 我非常希望这个项目是一个真正能使用的程序. 但是实际上, C++ 糟糕的环境拖累了它. &#x20;

无奈之下, 我只能自行实现一个 SDQL 编译器. 我希望 扩展 SDQL 的语法, 让它成为一个简单的编程语言, 并且将它连接到 LLVM IR.&#x20;

我曾经也考虑过使用 Rust 构建一个可解释的后台, 而不是直接使用 LLVM IR. 但是考虑到 Rust 对于 LLVM 大框架的支持明显要落后一些, 我不得不选择在 C++ 的基础上构造编译器.

除此之外, 我构想中的 SDQL 应该尽量基于适合列运算的数据结构. 我调查了很多框架, 最终选择了 Apache Arrow 作为基础数据结构.

GC 的选择更是难上加难. Rust 的近乎零开销的抽象是非常好的榜样, 但是它带来了非常复杂的语法. JVM 系的 GC 是复杂且高级的系统, 它很好, 但就是太重了. 这一切对于一个简单的DSL来说都太过复杂.

我最终选择模仿 Go 语言的协程运行时, 它很轻, 而且天生并发, SDQL 恰好天生需要多线程运算.&#x20;

可惜 Google 从来不在乎开发者的想法, Go -> LLVM IR 的路径是几乎不可复用的. 更重要的是 Go 语言对 LLVM IR 的支持进展非常缓慢.

实在是没有选择了, 我只能用 C++ 硬写一个极其轻量的Concurrent GC, 来完成我最初的目标.&#x20;

我不太想造轮子, 尤其是过于复杂, 过于基础的轮子. 在解析器上, 我仅仅使用了简单的自定义 AST, 就将它转换为 LLVM 提供的 MLIR 自定义 Dialect, 并通过 MLIR 提供的降级功能降级到 LLVM IR.&#x20;

运行时GC, 这种无数人踩过的史前大坑, 我现在不得不扑进去, 真tm人间疾苦.
